---
layout: post
title: 经历N次，今日重新开博~
category: tech
---

今天是2012年3月6日16点整，这是我的第N个博客，至于前几个不知道是什么原因慢慢就忘了，以至于现在我都想不起来博客放在哪个空间...
废话不多说，本博客使用jekyll引擎、Github版本控制、textile&markdown语法。最后感谢lzyy~


h3. 写博客的目的

# 记事目的
# 提高学习能力
# 提高语言组织能力
# 好玩

h3. 今日最糟糕代码

下面代码是在人物施放技能时候调用的，目前为止还没有完全搞懂，完全消化并且吸收需要时日。

{% highlight python %}
for(int i = 0;i<skillPos.length;i++){
  for(int j = 0;j<skillPos[i].length;j++){
    for(int k = 0;k<skillPos[i][j].length;k++){
      for(int z = 0;z<skillPos[i][j].length-k-1;z++){
			int a = skillsList[i][skillPos[i][j][z]].coordy;
			int b = skillsList[i][skillPos[i][j][z+1]].coordy;
			if(a>b){
			byte temp = skillPos[i][j][z];
			skillPos[i][j][z] = skillPos[i][j][z+1];
			skillPos[i][j][z+1] = temp;					
				}
			}
		}
	}
}
{% endhighlight %}

h3. 创建模型

创建一个继承Thing的基类，主要是设置数据库连接

{% highlight python %}
from sqlalchemy import create_engine
import thing

master_engine = create_engine('mysql://root:123456@localhost:3306/test')
slave_engine = create_engine('mysql://root:123456@localhost:3307/test')

class BaseThing(thing.Thing):
    def __init__(self):
        thing.Thing.__init__(self, {'master': master_engine, 
                                    'slave': slave_engine})
{% endhighlight %}

 
h5. 注意事项：

# 所有的模型类都要继承BaseThing
# 如果没有在子类里定义_tablename，则默认使用小写的子类名作为表名
# 表字段会被自动获取

假设有这么个场景：一个用户有多个答案，每个答案可以被多人投票。我们可以新建3个Model

{% highlight python %}
import thing
from sqlalchemy import create_engine
from formencode import validators
from blinker import signal

vote_before_insert = signal('vote.before_insert')

class Member(BaseThing):
    # 验证email字段
    email = validators.Email(messages = {'noAt': u'invalid email'})

    @property
    def answers(self):
        return Answer().where('member_id', '=', self.id)

class Answer(BaseThing):
    @property
    def votes(self):
        return Vote().where('answer_id', '=', self.id)

    @vote_before_insert.connect
    def _vote_before_insert(vote, data):
        if vote.answer.title == 'test':
            vote.errors = {'answer': 'signal test'}

class Vote(BaseThing):
    @property
    def member(self):
        return Member().where('id', '=', self.member_id).find()

    @property
    def answer(self):
        return Answer().where('id', '=', self.answer_id).find()
{% endhighlight %}

用户与答案是一对多的关系，这里通过@property装饰器来实现，在answers方法内，可以很灵活地实现答案获取的方法。

在Answer模型里有一个vote_before_insert装饰器，在vote执行insert操作前_vote_before_insert方法会被触发，可以在这里做很多事，如缓存的处理，数据的验证等等。如果验证不通过，可以设置sender的errors属性，该属性一旦被设置，后续的操作将被中断，在这里vote就不会执行insert操作。

h5. 注意事项：

# 验证使用的是formencode，这个库支持很多的验证操作，"http://www.formencode.org/en/latest/Validator.html":http://www.formencode.org/en/latest/Validator.html
# 一共有6类事件：model.before_validation / after_validation / before_insert / after_insert / before_update / after_update
# 事件触发时第一个参数为model本身，第二个参数为数据，如果在某个事件响应函数处，设置了model.errors属性，则此次事件之后的代码都不会执行。

h3. 使用

h4. 列出一个用户的id>10的所有回答，每次取10个

{% highlight python %}
member = Member().find(1)

for answer in member.answers.where('id', '>', 10).findall(limit=10, offset=0):
    print answer.title
{% endhighlight %}

h4. 创建新用户

{% highlight python %}
member = Member()
member.email = 'foo@bar.com'
member.password = '123'
member.save()
print member.saved # True
print member.email # foo@bar.com
{% endhighlight %}

h4. 更新用户信息

{% highlight python %}
member = Member().find(1)
member.email = 'foo@bar.com'
member.save()
print member.saved # True
print member.email # foo@bar.com
{% endhighlight %}

h4. 验证信息

{% highlight python %}
member = Member()
member.password = '123'
member.email = 'foo'
member.save()
print member.errors['email'] # invalid email
{% endhighlight %}

h3. 多数据库连接

{% highlight python %}
member = Member().find(1, 'slave')
{% endhighlight %}

在执行find / findall / save操作时，有一个db_section选项，如果忽略，则默认使用初始化时传入的engide dict的第一项，在这里就是master，如果想选择其他的数据库，传入该数据库对应的key就行，比如slave

h3. 其他

# 查看某次插入或更新是否成功，可以检查errors属性，如果为空表示执行成功
# 如果model的key中包含主键，如id，则执行save时是一个更新操作，否则为插入
# 欢迎fork / test / feedback
